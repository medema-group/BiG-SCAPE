""" Module containing code to load and store antiSMASH CDSs"""

# from python
from __future__ import annotations
from itertools import combinations
import logging
from typing import Optional, TYPE_CHECKING

# from dependencies
from Bio.SeqFeature import SeqFeature
from Bio.Seq import Seq

# from other modules
from src.errors import InvalidGBKError
from src.data import DB


# from circular imports
if TYPE_CHECKING:
    from src.genbank import GBK  # imported earlier in src.file_input.load_files


class CDS:
    """
    Class to describe a CDS within an antiSMASH GBK

    Attributes:
        gene_kind: str
        strand: Bool
        nt_start: int
        nt_stop: int
        aa_seq: SeqRecord.seq
        hsps: list[HSP]
    """

    def __init__(self, nt_start: int, nt_stop: int):
        self.nt_start = nt_start
        self.nt_stop = nt_stop
        self.parent_gbk: Optional[GBK] = None
        self.gene_kind: Optional[str] = None
        self.strand: Optional[int] = None
        self.aa_seq: str = ""
        self.hsps: list = []

        # db specific fields
        self._db_id: Optional[int] = None

    def save(self, commit=True):
        """Saves this CDS to the database and optionally executes a commit

        Args:
            commit (bool, optional): Whether to commit immediately after inserting this
            CDS. Defaults to True.
        """

        # get parent gbk id if available
        parent_gbk_id = None
        if self.parent_gbk is not None and self.parent_gbk._db_id is not None:
            parent_gbk_id = self.parent_gbk._db_id

        cds_table = DB.metadata.tables["cds"]
        insert_query = (
            cds_table.insert()
            .returning(cds_table.c.id)
            .values(
                gbk_id=parent_gbk_id,
                nt_start=self.nt_start,
                nt_stop=self.nt_stop,
                strand=self.strand,
                gene_kind=self.gene_kind,
                aa_seq=self.aa_seq,
            )
            .compile()
        )

        # in the above query we add a returning statement. This makes it so that the
        # sqlite engine will be in the middle of a transaction (trying to give us the
        # returned value) and means we cannot commit. We will do this after digesting
        # the reutrn statement further on
        cursor_result = DB.execute(insert_query, False)

        # get return value
        return_row = cursor_result.fetchone()
        self._db_id = return_row[0]

        # only now that we have handled the return we can commit
        if commit:
            DB.commit()

    @classmethod
    def parse(cls, feature: SeqFeature, parent_gbk: GBK):
        """Creates a cds object from a region feature in a GBK file"""

        if feature.type != "CDS":
            logging.error(
                "Feature is not of correct type! (expected: region, was: %s)",
                feature.type,
            )
            raise InvalidGBKError()

        # if fuzzy positions present follows behaviour described
        # here: https://biopython.org/docs/1.81/api/Bio.SeqFeature.html
        nt_start = int(feature.location.start)
        nt_stop = int(feature.location.end)
        strand = int(feature.location.strand)

        cds = cls(nt_start, nt_stop)
        cds.strand = strand
        cds.parent_gbk = parent_gbk

        if "gene_kind" in feature.qualifiers:
            gene_kind = str(feature.qualifiers["gene_kind"][0])
            cds.gene_kind = gene_kind

        nt_seq = feature.location.extract(parent_gbk.nt_seq)

        # if translation exists -> check if there is a match with biopython translation
        # if no match, pick AS version and issue warning

        if "translation" in feature.qualifiers:
            aa_seq = str(feature.qualifiers["translation"][0])

            correct_translation = check_translation(aa_seq, nt_seq, feature)

            if not correct_translation:
                logging.warning(
                    "CDS (%s, %s) from %s:"
                    " translation provided by antiSMASH and generated by biopython"
                    " do not match, consider checking if there is something"
                    " special with this CDS",
                    nt_start,
                    nt_stop,
                    parent_gbk.path,
                )

            cds.aa_seq = aa_seq
            return cds

        # if not translation available -> we try to generate it

        transl_nt_seq = get_translation(feature, nt_seq)

        if transl_nt_seq is None:
            logging.warning(
                "CDS (%s, %s) from %s:"
                " translation not found in cds feature and could not be generated,"
                " therefore this CDS feature is being discarded",
                nt_start,
                nt_stop,
                parent_gbk.path,
            )
            return None

        cds.aa_seq = transl_nt_seq
        return cds

    @staticmethod
    def has_overlap(cds_a: CDS, cds_b: CDS) -> bool:
        """Return True if there is overlap between this

        Args:
            cds_b (CDS): CDS to compare

        Returns:
            bool: whether there is overlap between this cds and another
        """
        has_overlap = CDS.len_nt_overlap(cds_a, cds_b) > 0
        return has_overlap

    @staticmethod
    def len_nt_overlap(cds_a: CDS, cds_b: CDS) -> int:
        """Return the length of the nucleotide seq overlap between two CDSs

        Args:
            cds_a,b (CDS): CDSs to compare

        Returns:
            int: length of the overlap between this CDS and another
        """
        if cds_a.strand != cds_b.strand:
            return 0

        if cds_a.nt_start < cds_b.nt_start:
            left = cds_b.nt_start
        else:
            left = cds_a.nt_start

        if cds_a.nt_stop > cds_b.nt_stop:
            right = cds_b.nt_stop
        else:
            right = cds_a.nt_stop

        # limit to > 0
        return max(0, right - left)

    @staticmethod
    def filter_overlap(cds_list: list[CDS], perc_overlap: float):
        """From a list of CDSs, filter out overlapping CDSs if overlap len exceeds
        a percentage of the shortest total CDS len

        Args:
            cds_list (list[CDS]): list of CDS
            perc_overlap (float): threshold to filter

        Returns:
            _type_: list[CDS]
        """

        # working with lists here is kind of iffy. in this case we are keeping track of\
        # which CDS we want to remove from the original list later on
        del_list = set()
        # find all combinations of cds to check for overlap
        cds_a: CDS
        cds_b: CDS
        for cds_a, cds_b in combinations(cds_list, 2):
            a_aa_len = len(cds_a.aa_seq)
            b_aa_len = len(cds_b.aa_seq)
            shortest_aa_len = min(a_aa_len, b_aa_len)

            # do not add to remove list if cds are on a different strand
            if cds_a.strand != cds_b.strand:
                continue

            # do not add to remove list if there is no overlap at all
            if not CDS.has_overlap(cds_a, cds_b):
                continue

            # calculate overlap in nt and convert to aa
            nt_overlap = CDS.len_nt_overlap(cds_a, cds_b)
            aa_overlap = nt_overlap / 3

            # allow the aa overlap to be as large as X% of the shortest CDS.
            if aa_overlap > perc_overlap * shortest_aa_len:
                if a_aa_len > b_aa_len:
                    del_list.add(cds_b)
                else:
                    del_list.add(cds_a)

        # remove any entries that need to be removed
        for cds in del_list:
            cds_list.remove(cds)

        return cds_list


def translate(feature: SeqFeature, nt_seq: Seq):
    """Translate a CDS sequence if CDS is valid

    Args:
        feature (SeqFeature): CDS SeqFeature
        nt_seq (Seq): CDS nucleotide sequence

    Returns:
        _type_: Seq
    """

    transl_table = None

    if "transl_table" in feature.qualifiers.keys():
        transl_table = feature.qualifiers["transl_table"][0]

    transl_nt_seq = nt_seq.translate(table=transl_table, to_stop=True)

    return transl_nt_seq


def trim_fuzzy(
    feature: SeqFeature, nt_seq: Seq, fuzzy_start: bool, fuzzy_end: bool, remainder: int
):
    """Method to trim an out-of-frame sequence based on fuzzies

    Fuzzy start: assume that end of sequence is in frame
    and trim from the beginning

    Fuzzy end: assume that the start of sequence is in frame
    and trim from the end

    Args:
        feature (SeqFeature): CDS SeqFeature
        nt_seq (Seq): CDS nucleotide sequence

    Returns:
        _type_: Seq or None
    """

    if fuzzy_start:
        if remainder == 1:
            trimmed_nt_seq = nt_seq[1:]
        else:
            trimmed_nt_seq = nt_seq[2:]

    if fuzzy_end:
        if remainder == 1:
            trimmed_nt_seq = nt_seq[:-1]
        else:
            trimmed_nt_seq = nt_seq[:-2]

    return trimmed_nt_seq


def check_translation(aa_seq: Seq, nt_seq: Seq, feature: SeqFeature):
    """Check if antiSMASH provided translation matches the one
    generated by Biopython

    Args:
        aa_seq (Seq): antiSMASH translation
        nt_seq (Seq): CDS nucleotide sequence
        feature (SeqFeature): CDS SeqFeature

    Returns:
        _type_: Bool
    """

    match = True

    transl_nt_seq = translate(feature, nt_seq)

    if not str(nt_seq) == str(transl_nt_seq):
        match = False

    return match


def get_translation(feature: SeqFeature, nt_seq: Seq):
    """Method to generate a Biopython translation from a CDS sequence

    If nt_seq is not divisible by 3, we try to trim it (trimming is possible
    if either fuzzy start or fuzzy end are present, but not if both or
    neither is present)

    Furthermore, no checks are performed for the presence of start/stop
    codons (biopython cds=True), as there is no influence on downstream analysis


    Args:
        feature (SeqFeature): CDS SeqFeature
        nt_seq (Seq): CDS nucleotide sequence

    Returns:
        _type_: Seq or None
    """

    remainder = len(nt_seq) % 3

    if remainder == 0:
        # if len nt_seq divisible by 3, we translate direclty
        transl_nt_seq = translate(feature, nt_seq)
        return transl_nt_seq

    # if len nt_seq not divisible by 3, we try to trim
    fuzzy_start = False
    fuzzy_end = False
    if "<>" in feature.location.start:
        fuzzy_start = True

    if "<>" in feature.location.end:
        fuzzy_end = True

    if fuzzy_start and fuzzy_end:
        # if both start and end are fuzzy, trimming will not generate
        # an in-frame sequence
        return None

    if not fuzzy_start and not fuzzy_end:
        # this should not happen, but just in case
        # if no fuzzies, then can't trim using the method below
        return None

    trimmed_nt_seq = trim_fuzzy(feature, nt_seq, fuzzy_start, fuzzy_end, remainder)

    transl_nt_seq = translate(feature, trimmed_nt_seq)

    return transl_nt_seq
