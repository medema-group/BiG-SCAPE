"""Contains code relevant to the CDS component"""

# from python
from __future__ import annotations
import logging
from typing import Optional

# from dependencies
from Bio.SeqFeature import SeqFeature
from Bio.SeqRecord import SeqRecord

# from other modules
from big_scape.errors import InvalidGBKError
from big_scape.genbank.cds import check_translation, get_translation
import big_scape.enums as bs_enums
from big_scape.dereplicating.gbk_components.gbk import GBK

# from this module


class CDS:
    """
    Class to describe a CDS component

    Attributes:
        nt_start (int): start position of the CDS in the nucleotide sequence
        nt_end (int): end position of the CDS in the nucleotide sequence
        biosynthetic (bool): whether the CDS is core biosynthetic
        aa_sequence (Bio.Seq): amino acid sequence of the CDS

    """

    def __init__(
        self, nt_start: int, nt_stop: int, strand: int, gene_kind: str, aa_sequence: str
    ) -> None:
        self.enum: bs_enums.COMPONENTS = bs_enums.COMPONENTS.CDS
        self.nt_start: int = nt_start
        self.nt_stop: int = nt_stop
        self.strand: int = strand
        self.gene_kind: Optional[str] = gene_kind
        self.aa_sequence: str = aa_sequence
        self.orf_num: Optional[int] = None

    @classmethod
    def parse(cls, feature: SeqFeature, seqIO_record: SeqRecord, gbk: GBK) -> CDS:
        """Parses a SeqFeature object and returns a CDS object

        Args:
            feature (SeqFeature): SeqFeature object to parse

        Returns:
            CDS: CDS object
        """

        if feature.type != "CDS":
            logging.error(
                "Feature is not of correct type! (expected: CDS, was: %s)",
                feature.type,
            )
            raise InvalidGBKError()

        # if fuzzy positions present follows behaviour described
        # here: https://biopython.org/docs/1.81/api/Bio.SeqFeature.html
        nt_start = int(feature.location.start)
        nt_stop = int(feature.location.end)
        strand = int(feature.location.strand)

        gene_kind = ""
        if "gene_kind" in feature.qualifiers:
            gene_kind = feature.qualifiers["gene_kind"][0]

        elif "sec_met" in feature.qualifiers:
            for sec_met_value in feature.qualifiers["sec_met"]:
                if "Kind" in sec_met_value:
                    gene_kind = sec_met_value[6:]  # trim "Kind: "
                    break
        else:
            logging.debug(
                "No gene_kind or sec_met qualifier found for CDS (%s, %s) from %s:",
                nt_start,
                nt_stop,
                gbk.path,
            )

        nt_seq = feature.location.extract(seqIO_record.seq)

        # if translation exists -> check if there is a match with biopython translation
        # if no match, pick AS version and issue warning

        if "translation" in feature.qualifiers:
            aa_seq = str(feature.qualifiers["translation"][0])

            correct_translation = check_translation(aa_seq, nt_seq, feature)

            if (
                not correct_translation
                # TODO when implementing CLUSTER/QUERY:
                # and not parent_gbk.source_type == SOURCE_TYPE.MIBIG
            ):
                logging.debug(
                    "CDS (%s, %s) from %s:"
                    " translation provided by antiSMASH and generated by biopython"
                    " do not match, likely due to fuzzy starts/ends."
                    " Consider checking if there is something special with this CDS",
                    nt_start,
                    nt_stop,
                    gbk.path,
                )

            return cls(nt_start, nt_stop, strand, gene_kind, aa_seq)

        # if not translation available -> we try to generate it

        transl_nt_seq = get_translation(feature, nt_seq)

        # we can't work with a CDS that has no AA seq so ignore it by returning None
        if transl_nt_seq is None:
            logging.warning(
                "CDS (%s, %s) from %s:"
                " translation not found in cds feature and could not be generated,"
                " therefore this CDS feature is being discarded",
                nt_start,
                nt_stop,
                gbk.path,
            )
            return None

        return cls(nt_start, nt_stop, strand, gene_kind, transl_nt_seq)

    @staticmethod
    def process(gbk: GBK, cds_overlap_cutoff=0.1) -> None:
        """Processes the CDS component of a GBK object

        Args:
            gbk (GBK): GBK object to process
        """

        # set orf number
        CDS.set_orf_number(gbk)

        # filter out overlapping CDSs
        CDS.filter_overlap(gbk, cds_overlap_cutoff)

        return None

    @staticmethod
    def set_orf_number(gbk: GBK) -> None:
        """_summary_

        Args:
            gbk (GBK): _description_
            cds_overlap_cutoff (float, optional): _description_. Defaults to 0.1.

        Returns:
            _type_: _description_
        """

        cds_list = gbk.components[bs_enums.COMPONENTS.CDS]

        # add ORF number to each CDS, we need orf nums later on
        # but trust the order of the gbk parsing
        for i, cds in enumerate(cds_list):
            cds.orf_num = i + 1

        return None

    @staticmethod
    def filter_overlap(gbk: GBK, cds_overlap_cutoff=0.1) -> None:
        """Takes a GBK and removes overlapping CDSs from its CDS component.
        Performs overlap cutoff filtering by calculating the
        percentage overlap of the incoming CDS with other CDS in this GBK.

        If the percentage overlap is greater than the cutoff, this keeps whichever CDS
        is longer. If scores are equal, this keeps the HSP with the earliest
        start position. Bitscores are rounded to 1 decimal position when compared.

        Args:
            gbk (GBK): GBK object to filter
            cds_overlap_cutoff (float, optional): Length threshold to define overlap. Defaults to 0.1.

        Returns:
           None
        """

        cds_list = gbk.components[bs_enums.COMPONENTS.CDS]

        filtered_cds_list = [cds_list[0]]

        for cds in cds_list[1:]:
            replaced_cds = False

            # for each cds we need to check if it overlaps with any of the already existing cds
            for prev_cds_idx, prev_cds in enumerate(filtered_cds_list):
                # if two cds are not in the same strand, they cant overlap
                if cds.strand != prev_cds.strand:
                    continue

                overlap_nt = CDS.len_nt_overlap(cds, prev_cds)

                if overlap_nt == 0:
                    continue

                overlap_aa = overlap_nt / 3

                # we determine overlap as a percentage of shortest cds
                prev_cds_aa_len = len(prev_cds.aa_sequence)
                cds_aa_len = len(cds.aa_sequence)
                shortest_aa_len = min(prev_cds_aa_len, cds_aa_len)

                # if the overlap is less than the cutoff, we skip
                if overlap_aa <= cds_overlap_cutoff * shortest_aa_len:
                    continue

                # there is sufficient overlap, so we will replace a cds
                replaced_cds = True

                # there is sufficient overlap but new cds is shorter, we skip
                if cds_aa_len < prev_cds_aa_len:
                    logging.debug(
                        "%s: Removing %s because it overlaps with another CDS %s",
                        gbk.path,
                        cds,
                        filtered_cds_list[prev_cds_idx],
                    )
                    continue

                # there is sufficient overlap and new cds is longer, we replace
                logging.debug(
                    "%s: Removing %s because it overlaps with another CDS",
                    gbk.path,
                    filtered_cds_list[prev_cds_idx],
                    cds,
                )
                del filtered_cds_list[prev_cds_idx]
                filtered_cds_list.append(cds)

            # if no cds was replaced, we add it to the list
            if not replaced_cds:
                filtered_cds_list.append(cds)

        gbk.components[bs_enums.COMPONENTS.CDS] = filtered_cds_list

        return None

    @staticmethod
    def len_nt_overlap(cds_a: CDS, cds_b: CDS) -> int:
        """Return the length of the nucleotide seq overlap between two CDSs

        Args:
            cds_a,b (CDS): CDSs to compare

        Returns:
            int: length of the overlap between this CDS and another
        """
        if cds_a.nt_start < cds_b.nt_start:
            left = cds_b.nt_start
        else:
            left = cds_a.nt_start

        if cds_a.nt_stop > cds_b.nt_stop:
            right = cds_b.nt_stop
        else:
            right = cds_a.nt_stop

        # limit to > 0
        return max(0, right - left)

    @staticmethod
    def concatenate_cds(gbk: GBK) -> None:
        """Concatenates the aa_seqs of all CDSs into a new component of the GBK object

        Args:
            gbk (GBK): gbk
        """

        cds_list = gbk.components[bs_enums.COMPONENTS.CDS]

        # concatenate all aa_seqs
        concat_aa_seq = "".join([cds.aa_sequence for cds in cds_list])

        gbk.components[bs_enums.COMPONENTS.CONCAT_CDS] = concat_aa_seq

        return None

    def __gt__(self, __o) -> bool:
        if not isinstance(__o, CDS):
            raise NotImplementedError()
        return self.nt_start > __o.nt_start
