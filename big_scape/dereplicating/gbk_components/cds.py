"""Contains code relevant to the CDS component"""

# from python
from __future__ import annotations
import logging
from typing import Optional

# from dependencies
from Bio.SeqFeature import SeqFeature
from Bio.SeqRecord import SeqRecord

# from other modules
from big_scape.errors import InvalidGBKError
from big_scape.genbank.cds import check_translation, get_translation
import big_scape.enums as bs_enums

# from this module
from .gbk import GBK


class CDS:
    """
    Class to describe a CDS component

    Attributes:
        nt_start (int): start position of the CDS in the nucleotide sequence
        nt_end (int): end position of the CDS in the nucleotide sequence
        biosynthetic (bool): whether the CDS is core biosynthetic
        aa_sequence (Bio.Seq): amino acid sequence of the CDS

    """

    def __init__(
        self, nt_start: int, nt_stop: int, strand: int, gene_kind: str, aa_sequence: str
    ) -> None:
        self.name: bs_enums.COMPONENTS = bs_enums.COMPONENTS.CDS
        self.nt_start: int = nt_start
        self.nt_stop: int = nt_stop
        self.strand: int = strand
        self.gene_kind: Optional[str] = gene_kind
        self.aa_sequence: str = aa_sequence

    @classmethod
    def parse(cls, feature: SeqFeature, seqIO_record: SeqRecord, gbk: GBK) -> CDS:
        """Parses a SeqFeature object and returns a CDS object

        Args:
            feature (SeqFeature): SeqFeature object to parse

        Returns:
            CDS: CDS object
        """

        if feature.type != "CDS":
            logging.error(
                "Feature is not of correct type! (expected: CDS, was: %s)",
                feature.type,
            )
            raise InvalidGBKError()

        # if fuzzy positions present follows behaviour described
        # here: https://biopython.org/docs/1.81/api/Bio.SeqFeature.html
        nt_start = int(feature.location.start)
        nt_stop = int(feature.location.end)
        strand = int(feature.location.strand)

        if "gene_kind" in feature.qualifiers:
            gene_kind = feature.qualifiers["gene_kind"][0]

        elif "sec_met" in feature.qualifiers:
            for sec_met_value in feature.qualifiers["sec_met"]:
                if "Kind" in sec_met_value:
                    gene_kind = sec_met_value[6:]  # trim "Kind: "
                    break
        else:
            logging.debug(
                "No gene_kind or sec_met qualifier found for CDS (%s, %s) from %s:",
                nt_start,
                nt_stop,
                gbk.path,
            )
            gene_kind = None

        nt_seq = feature.location.extract(seqIO_record.seq)

        # if translation exists -> check if there is a match with biopython translation
        # if no match, pick AS version and issue warning

        if "translation" in feature.qualifiers:
            aa_seq = str(feature.qualifiers["translation"][0])

            correct_translation = check_translation(aa_seq, nt_seq, feature)

            if (
                not correct_translation
                # TODO when implementing CLUSTER/QUERY:
                # and not parent_gbk.source_type == SOURCE_TYPE.MIBIG
            ):
                logging.debug(
                    "CDS (%s, %s) from %s:"
                    " translation provided by antiSMASH and generated by biopython"
                    " do not match, likely due to fuzzy starts/ends."
                    " Consider checking if there is something special with this CDS",
                    nt_start,
                    nt_stop,
                    gbk.path,
                )

            return cls(nt_start, nt_stop, strand, gene_kind, aa_seq)

        # if not translation available -> we try to generate it

        transl_nt_seq = get_translation(feature, nt_seq)

        # we can't work with a CDS that has no AA seq so ignore it by returning None
        if transl_nt_seq is None:
            logging.warning(
                "CDS (%s, %s) from %s:"
                " translation not found in cds feature and could not be generated,"
                " therefore this CDS feature is being discarded",
                nt_start,
                nt_stop,
                gbk.path,
            )
            return None

        return cls(nt_start, nt_stop, strand, gene_kind, aa_seq)

    def __gt__(self, __o) -> bool:
        if not isinstance(__o, CDS):
            raise NotImplementedError()
        return self.nt_start > __o.nt_start
