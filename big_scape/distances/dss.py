"""Contains code to calculate the DSS for a pair of BGCs. Also contains a helper
function to perform calculation for all BGCs in a bin using just-in-time execution of
HHMAlign

NOTE: this is currently not being used!
"""

# from python
from typing import Optional

# from dependencies
from numpy import ndarray
from scipy.optimize import linear_sum_assignment

# from other modules
from big_scape.cli.config import BigscapeConfig
from big_scape.comparison.record_pair import RecordPair

# from this module


# TODO: module lacks tests


def get_distance_from_unshared(
    bgc_pair: RecordPair, anchor_domains: set[str]
) -> tuple[float, float]:
    """Get the distance for anchor and non-anchor domains for a pair of BGCs based upon
    the unshared domains. Each domain that is unshared adds 1.0 to either distance

    Args:
        bgc_pair (BGCPair): BGCPair object to calculate this distance metric for
        anchor_domains (set[str]): A set of strings corresponding to anchor domains.
        Unshared domains that match this strings add 1.0 to distance_anchor

    Returns:
        tuple[float, float]: Two scores for the distance of non-anchor domains and of
        anchor domains, respectively
    """
    # these are the cumulative distances for non-anchor and anchor domains
    distance_non_anchor = 0.0
    distance_anchor = 0.0

    # we will need both sets and lists in order to calculate the DSS
    a_domain_set, b_domain_set = bgc_pair.get_domain_sets()
    a_domain_dict, b_domain_dict = bgc_pair.get_domain_dicts()

    # first lets get the distance generated by domains that are not shared between BGCs
    unshared_domains = a_domain_set.symmetric_difference(b_domain_set)

    # any such unshared domain is counted as a full miss (1.0 distance)
    for unshared_domain in unshared_domains:
        if unshared_domain in a_domain_set:
            unshared_count = len(a_domain_dict[unshared_domain])

        if unshared_domain in b_domain_set:
            unshared_count = len(b_domain_dict[unshared_domain])

        if unshared_domain in anchor_domains:
            distance_anchor += unshared_count
            continue

        distance_non_anchor += unshared_count

    return distance_anchor, distance_non_anchor


def get_aligned_string_dist(string_a: str, string_b: str) -> float:
    """Calculate a simple distance between two strings of equal length from an MSA

    Strings must be equal lengths.

    Args:
        string_a (str): String to calculate distance for
        string_b (str): String to calculate distance for

    Raises:
        ValueError: Raised when string lengths do not match

    Returns:
        float: Simple distance of the two passed strings
    """
    if len(string_a) != len(string_b):
        raise ValueError(
            "String A and String B length difference in get_aligned_string_dist"
        )

    gaps = 0
    matches = 0

    for char_idx in range(len(string_a)):
        if string_a[char_idx] == string_b[char_idx]:
            if string_a[char_idx] == "-":
                gaps += 1
            else:
                matches += 1

    similarity = matches / (len(string_a) - gaps)

    return 1 - similarity


def get_sum_seq_dist(
    a_domain_list, b_domain_list, a_domain_dict, b_domain_dict, shared_domain
) -> tuple[float, int]:  # pragma no cover
    """Get the sum of the distances between the sequences of two domains"""

    a_domain_count = len(a_domain_dict[shared_domain])
    b_domain_count = len(b_domain_dict[shared_domain])

    distance_matrix: ndarray = ndarray((a_domain_count, b_domain_count))

    for a_idx, a_list_idx in enumerate(a_domain_dict[shared_domain]):
        for b_idx, b_list_idx in enumerate(b_domain_dict[shared_domain]):
            string_a = a_domain_list[a_list_idx].alignment.align_string
            string_b = b_domain_list[b_list_idx].alignment.align_string

            alignment_dist = get_aligned_string_dist(string_a, string_b)

            distance_matrix[a_idx][b_idx] = alignment_dist

    best_indexes = linear_sum_assignment(distance_matrix)
    accumulated_distance: float = distance_matrix[best_indexes].sum()

    domain_count_diff = abs(a_domain_count - b_domain_count)

    sum_seq_dist = domain_count_diff + accumulated_distance
    normalization_element = max(a_domain_count, b_domain_count)

    return sum_seq_dist, normalization_element


def get_distance_from_shared(
    record_pair: RecordPair, anchor_domains: set[str]
):  # pragma no cover
    """Get the distance for anchor and non-anchor domains for a pair of BGCs based upon
    the shared domains. Each domain that is shared adds a distance based upon the
    alignment of the domain sequences

    Args:
        record_pair (RecordPair): RecordPair object to calculate this distance metric
        for

    Returns:
        tuple[float, float]: Two scores for the distance of non-anchor domains and of
        anchor domains, respectively
    """

    domain_set_a, domain_set_b = record_pair.get_domain_sets()
    a_domain_list, b_domain_list = record_pair.get_domain_lists()
    a_domain_dict, b_domain_dict = record_pair.get_domain_dicts()

    intersect = domain_set_a & domain_set_b

    distance_anchor = 0.0
    distance_non_anchor = 0.0

    domains_anchor = 0
    domains_non_anchor = 0

    for shared_domain in intersect:
        sum_seq_dist, normalization_element = get_sum_seq_dist(
            a_domain_list, b_domain_list, a_domain_dict, b_domain_dict, shared_domain
        )

        if shared_domain in anchor_domains:
            distance_anchor += sum_seq_dist
            domains_anchor += normalization_element
        else:
            distance_non_anchor += sum_seq_dist
            domains_non_anchor += normalization_element

    return distance_anchor, distance_non_anchor, domains_anchor, domains_non_anchor


def calc_dss_pair(
    record_pair: RecordPair,
    anchor_domains: Optional[set[str]] = None,
    anchor_boost: float = 1.0,
) -> float:  # pragma no cover
    """Calculate the DSS for a pair of records

    Args:
        record_pair (RecordPair): Pair of records to calculate DSS for
        anchor_domains (Optional[set[str]], optional): Set of anchor domains. Defaults
            to None.
        anchor_boost (float): boost the importance of anchor domains in DSS calculation

    Returns:
        float: DSS score for the pair of records
    """

    # intialize an empty set of anchor domains if it is set to None
    if anchor_domains is None:
        anchor_domains = set(BigscapeConfig.ANCHOR_DOMAINS)

    # initialize the distances by getting the distances from all unshared domains, which
    # all add 1 to the difference
    distance_anchor, distance_non_anchor = get_distance_from_unshared(
        record_pair, anchor_domains
    )

    # since we know we added whole numbers in the above function, we can re-use the
    # results to get the number of domains that we used
    domains_anchor = int(distance_anchor)
    domains_non_anchor = int(distance_non_anchor)

    # now we have to do add the distances that we get from procesing the alignments
    # s_ means shared
    (
        s_dist_anchor,
        s_dist_non_anchor,
        s_domains_anchor,
        s_domains_non_anchor,
    ) = get_distance_from_shared(record_pair, anchor_domains)

    distance_anchor += s_dist_anchor
    distance_non_anchor += s_dist_non_anchor

    domains_anchor += s_domains_anchor
    domains_non_anchor += s_domains_non_anchor

    # finally calculate the score
    # first case: no anchor domains
    if domains_anchor == 0:
        return 1 - distance_non_anchor / domains_non_anchor

    # second case: no non-anchor domains
    if domains_non_anchor == 0:
        return 1 - distance_anchor / domains_anchor

    # third case: mix of both
    dss_anchor = distance_anchor / domains_anchor
    dss_non_anchor = distance_non_anchor / domains_non_anchor

    # Calculate proper, proportional weight to each kind of domain
    anchor_percent = (domains_anchor * anchor_boost) / (
        domains_non_anchor + domains_anchor
    )
    # non_anchor_percent = domains_non_anchor / (domains_anchor + domains_anchor)
    non_anchor_percent = domains_non_anchor / (domains_non_anchor + domains_anchor)

    # boost anchor subcomponent and re-normalize
    non_anchor_weight = non_anchor_percent / (anchor_percent + non_anchor_percent)
    anchor_weight = anchor_percent / (anchor_percent + non_anchor_percent)

    # Use anchorboost parameter to boost percieved rDSS_anchor
    dss = (non_anchor_weight * dss_non_anchor) + (anchor_weight * dss_anchor)

    return 1 - dss
